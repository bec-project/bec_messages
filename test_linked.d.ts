/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type TypeName = string;

/**
 * Message for ACL accounts
 *
 * Args:
 *     accounts (dict): ACL accounts
 */
export interface ACLAccountsMessage {
  metadata?: Metadata;
  accounts: Accounts;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface Accounts {
  [k: string]: {
    [k: string]: string[] | string;
  };
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Severity = number;
export type Id = string;
export type ErrorMessage = string;
export type CompactErrorMessage = string | null;
export type ExceptionType = string;
export type Device = string | string[] | null;
export type TypeName = string;

/**
 * Alarm message
 *
 * Args:
 *     severity (Alarms, Literal[0,1,2]): Severity level (0-2). ALARMS.WARNING = 0, ALARMS.MINOR = 1, ALARMS.MAJOR = 2
 *     info (ErrorInfo): Error information.
 *     metadata (dict, optional): Additional metadata.
 */
export interface AlarmMessage {
  metadata?: Metadata;
  severity: Severity;
  info: ErrorInfo;
  bec_codec: BecCodecInfo1;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface ErrorInfo {
  id?: Id;
  error_message: ErrorMessage;
  compact_error_message: CompactErrorMessage;
  exception_type: ExceptionType;
  device?: Device;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
export interface BecCodecInfo1 {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Resource =
  | {
      [k: string]: unknown;
    }
  | {
      [k: string]: unknown;
    }[];
export type TypeName = string;

/**
 * Message for available resources such as scans, data processing plugins etc
 *
 * Args:
 *     resource (dict, list[dict]): Resource description
 *     metadata (dict, optional): Metadata. Defaults to None.
 */
export interface AvailableResourceMessage {
  metadata?: Metadata;
  resource: Resource;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type TypeName = string;

/**
 * Base Model class for BEC Messages
 *
 * Args:
 *     msg_type (str): ClassVar for the message type, subclasses should override this.
 *     metadata (dict, optional): Optional dictionary with metadata for the BECMessage
 */
export interface BECMessage {
  metadata?: Metadata;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type TypeName = string;

export interface BECSerializable {
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface BECStatus {
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type TypeName = string;

export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Messages = unknown[];
export type TypeName = string;

/**
 * Message type to send a bundle of BECMessages.
 *
 * Used to bundle together various messages, i.e. used to emit data in the scan bundler.
 *
 * Args:
 *     messages (list): List of BECMessage objects that are bundled together
 *     metadata (dict, optional): Additional metadata to describe the scan
 *
 * Examples:
 *     >>> BundleMessage(messages=[ScanQueueMessage(...), ScanStatusMessage(...)], metadata = {...})
 */
export interface BundleMessage {
  metadata?: Metadata;
  messages?: Messages;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Message = string;
export type ShowAsap = boolean;
export type Rid = string | null;
export type Source =
  | "bec_ipython_client"
  | "scan_server"
  | "device_server"
  | "scan_bundler"
  | "file_writer"
  | "scihub"
  | "dap"
  | null;
export type Scope = string | null;
export type Severity = number;
/**
 * Time in seconds after which the message expires and should not be shown anymore. Defaults to 60 seconds. Set it to 0 to never expire the message.
 */
export type Expire = number;
export type TypeName = string;

/**
 * Message type for sending information to the client
 * Args:
 *     message (str): message to the client
 *     show_asap (bool, optional): True if the message should be shown immediately. Defaults to True
 *     # Note: The option show_asap = True/False is temporary disabled until a decision is made on how to handle it. TODO #286
 *     RID (str, optional): Request ID forwarded from the service, if available will be used to filter on the client site. Defaults to None.
 *     source (str, Literal[
 *         "bec_ipython_client",
 *         "scan_server",
 *         "device_server",
 *         "scan_bundler",
 *         "file_writer",
 *         "scihub",
 *         "dap",
 *         None]
 *         : Source of the message. Defaults to None.
 *     scope (str, optional): Scope of the message; Defaults to None. One can follow
 *                            a pattern to filter afterwards for specific client info; e.g. "scan", "rotation"
 *     severity (int, optional): severity level of the message (0: INFO, 1: WARNING, 2: ERROR); Defaults to 0
 *     expire (float, optional): Time in seconds after which the message expires and should not be shown anymore.
 *                               Defaults to 60 seconds. Set it to 0 to never expire the message.
 */
export interface ClientInfoMessage {
  metadata?: Metadata;
  message: Message;
  show_asap?: ShowAsap;
  RID?: Rid;
  source?: Source;
  scope?: Scope;
  severity?: Severity;
  expire?: Expire;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type TypeName = string;

/**
 * Message for credentials
 *
 * Args:
 *     credentials (dict): Credentials
 *     metadata (dict, optional): Metadata. Defaults to None.
 */
export interface CredentialsMessage {
  metadata?: Metadata;
  credentials: Credentials;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface Credentials {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type TypeName = string;

/**
 * Message for DAP configuration
 *
 * Args:
 *     config (dict): DAP configuration dictionary
 *     metadata (dict, optional): Metadata. Defaults to None.
 */
export interface DAPConfigMessage {
  metadata?: Metadata;
  config: Config;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface Config {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type DapCls = string;
export type DapType = "continuous" | "on_demand";
export type TypeName = string;

/**
 * Message for DAP requests
 *
 * Args:
 *     dap_cls (str): DAP class name
 *     dap_type (Literal["continuous", "on_demand"]) : Different types of DAP modes
 *     config (dict): DAP configuration
 *     metadata (dict, optional): Metadata. Defaults to None.
 */
export interface DAPRequestMessage {
  metadata?: Metadata;
  dap_cls: DapCls;
  dap_type: DapType;
  config: Config;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface Config {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Success = boolean;
export type Data = unknown[] | null;
export type Error = string | null;
export type TypeName = string;

/**
 * Message for DAP responses
 *
 * Args:
 *     success (bool): True if the request was successful
 *     data (tuple, optional): DAP data (tuple of data (dict) and metadata). Defaults to ({} , None).
 *     error (str, optional): DAP error. Defaults to None.
 *     dap_request (BECMessage, None): DAP request. Defaults to None.
 *     metadata (dict, optional): Metadata. Defaults to None.
 */
export interface DAPResponseMessage {
  metadata?: Metadata;
  success: Success;
  data?: Data;
  error?: Error;
  dap_request?: BECMessage | null;
  bec_codec: BecCodecInfo1;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
/**
 * Base Model class for BEC Messages
 *
 * Args:
 *     msg_type (str): ClassVar for the message type, subclasses should override this.
 *     metadata (dict, optional): Optional dictionary with metadata for the BECMessage
 */
export interface BECMessage {
  metadata?: Metadata1;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata1 {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
export interface BecCodecInfo1 {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Type = "add" | "add_slice" | "replace";
export type MaxShape = (number | null)[] | null;
export type Index = number | null;
export type TypeName = string;

/**
 * Model for validating async update metadata sent with device data.
 *
 * The async update metadata controls how data is aggregated into datasets during a scan:
 * - add: Appends data to the existing dataset along the first axis
 * - add_slice: Appends a slice of data at a specific index (max 2D datasets)
 * - replace: Replaces the existing dataset (written after scan completion)
 *
 * Args:
 *     type (Literal["add", "add_slice", "replace"]): Type of async update operation
 *     max_shape (list[int | None], optional): Maximum shape of the dataset. Required for 'add' and 'add_slice' types.
 *                                              Use None for unlimited dimensions. E.g., [None] for 1D unlimited.
 *                                              None values must only appear at the beginning (e.g., [None, 1024] is valid, [1024, None] is not).
 *                                              When all dimensions are None, maximum is 2 dimensions (e.g., [None, None] is valid, [None, None, None] is not).
 *                                              For 'add_slice' type, max_shape cannot exceed two dimensions.
 *     index (int, optional): Row index for 'add_slice' operations. Required only for 'add_slice' type.
 *
 * Examples:
 *     >>> DeviceAsyncUpdate(type="add", max_shape=[None])
 *     >>> DeviceAsyncUpdate(type="add", max_shape=[None, 1024, 1024])
 *     >>> DeviceAsyncUpdate(type="add_slice", max_shape=[None, 1024], index=5)
 *     >>> DeviceAsyncUpdate(type="replace")
 */
export interface DeviceAsyncUpdate {
  type: Type;
  max_shape?: MaxShape;
  index?: Index;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Action = ("add" | "set" | "update" | "reload" | "remove" | "reset" | "cancel") | null;
export type Config = {
  [k: string]: unknown;
} | null;
export type TypeName = string;

/**
 * Message type for sending device config updates
 *
 * Args:
 *     action (Literal['add', 'set', 'update', 'reload', 'reset', 'remove', 'cancel']) : Update of the device config.
 *     config (dict, or None): Device config (add, set, update) or None (reload, reset).
 *     metadata (dict, optional): Additional metadata.
 */
export interface DeviceConfigMessage {
  metadata?: Metadata;
  action?: Action;
  config?: Config;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Device = string;
export type TypeName = string;

/**
 * Message type for sending device info updates from the device server
 *
 * Args:
 *     device (str): Device name.
 *     info (dict): Device info as a dictionary.
 *     metadata (dict, optional): Additional metadata.
 */
export interface DeviceInfoMessage {
  metadata?: Metadata;
  device: Device;
  info: Info;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface Info {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Device = string;
export type Finished = boolean;
export type Success = boolean;
export type Index = number;
export type Total = number;
export type TypeName = string;

/**
 * Message type for sending device initialization progress updates
 *
 * Args:
 *     device (str): Device name.
 *     finished (bool): True if the initialization is finished.
 *     success (bool): True if the initialization was successful.
 *     index (int): Current progress index.
 *     total (int): Total number of steps for initialization.
 *     metadata (dict, optional): Additional metadata.
 */
export interface DeviceInitializationProgressMessage {
  metadata?: Metadata;
  device: Device;
  finished: Finished;
  success: Success;
  index: Index;
  total: Total;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Device = string | string[] | null;
export type Action =
  | "rpc"
  | "set"
  | "read"
  | "kickoff"
  | "complete"
  | "trigger"
  | "stage"
  | "unstage"
  | "pre_scan"
  | "wait"
  | "scan_report_instruction"
  | "open_scan"
  | "baseline_reading"
  | "close_scan"
  | "open_scan_def"
  | "close_scan_def"
  | "publish_data_as_read"
  | "close_scan_group";
export type TypeName = string;

/**
 * Message type for sending device instructions to the device server
 *
 * Args:
 *     device (str, list[str], None): Device name, list of device names or None
 *     action (Literal[ "rpc",
 *                     "set",
 *                     "read",
 *                     "kickoff",
 *                     "complete",
 *                     "trigger",
 *                     "stage",
 *                     "unstage",
 *                     "pre_scan",
 *                     "wait",
 *                     "scan_report_instruction",
 *                     "open_scan",
 *                     "baseline_reading",
 *                     "close_scan",
 *                     "open_scan_def",
 *                     "close_scan_def",
 *                     "publish_data_as_read",
 *                     "close_scan_group",
 *                     ]) : Device action, note rpc calls can run any method of the device. The function name needs to be specified in parameters['func']
 *     parameter (dict): Parameters required for the device action
 *     metadata (dict, optional): Metadata to describe the conditions of the device instruction
 *
 * Examples:
 *     >>> DeviceInstructionMessage(device="samx", action="stage", parameter={})
 */
export interface DeviceInstructionMessage {
  metadata?: Metadata;
  device: Device;
  action: Action;
  parameter: Parameter;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface Parameter {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Device = string | string[] | null;
export type Status = "completed" | "running" | "error";
export type Id = string;
export type ErrorMessage = string;
export type CompactErrorMessage = string | null;
export type ExceptionType = string;
export type Device1 = string | string[] | null;
export type TypeName = string;
export type Device2 = string | string[] | null;
export type Action =
  | "rpc"
  | "set"
  | "read"
  | "kickoff"
  | "complete"
  | "trigger"
  | "stage"
  | "unstage"
  | "pre_scan"
  | "wait"
  | "scan_report_instruction"
  | "open_scan"
  | "baseline_reading"
  | "close_scan"
  | "open_scan_def"
  | "close_scan_def"
  | "publish_data_as_read"
  | "close_scan_group";
export type InstructionId = string;

export interface DeviceInstructionResponse {
  metadata?: Metadata;
  device: Device;
  status: Status;
  error_info?: ErrorInfo | null;
  instruction: DeviceInstructionMessage;
  instruction_id: InstructionId;
  result?: unknown;
  bec_codec: BecCodecInfo2;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface ErrorInfo {
  id?: Id;
  error_message: ErrorMessage;
  compact_error_message: CompactErrorMessage;
  exception_type: ExceptionType;
  device?: Device1;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/**
 * Message type for sending device instructions to the device server
 *
 * Args:
 *     device (str, list[str], None): Device name, list of device names or None
 *     action (Literal[ "rpc",
 *                     "set",
 *                     "read",
 *                     "kickoff",
 *                     "complete",
 *                     "trigger",
 *                     "stage",
 *                     "unstage",
 *                     "pre_scan",
 *                     "wait",
 *                     "scan_report_instruction",
 *                     "open_scan",
 *                     "baseline_reading",
 *                     "close_scan",
 *                     "open_scan_def",
 *                     "close_scan_def",
 *                     "publish_data_as_read",
 *                     "close_scan_group",
 *                     ]) : Device action, note rpc calls can run any method of the device. The function name needs to be specified in parameters['func']
 *     parameter (dict): Parameters required for the device action
 *     metadata (dict, optional): Metadata to describe the conditions of the device instruction
 *
 * Examples:
 *     >>> DeviceInstructionMessage(device="samx", action="stage", parameter={})
 */
export interface DeviceInstructionMessage {
  metadata?: Metadata1;
  device: Device2;
  action: Action;
  parameter: Parameter;
  bec_codec: BecCodecInfo1;
  [k: string]: unknown;
}
export interface Metadata1 {
  [k: string]: unknown;
}
export interface Parameter {
  [k: string]: unknown;
}
export interface BecCodecInfo1 {
  type_name: TypeName;
  [k: string]: unknown;
}
export interface BecCodecInfo2 {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type TypeName = string;

/**
 * Message type for sending device readings from the device server
 *
 * Args:
 *     signals (dict): Dictionary containing the device signals and their values
 *     metadata (dict, optional): Metadata to describe the conditions of the device reading
 *
 * Examples:
 *     >>> BECMessage.DeviceMessage(signals={'samx': {'value': 14.999033949016491, 'timestamp': 1686385306.0265112}, 'samx_setpoint': {'value': 15.0, 'timestamp': 1686385306.016806}, 'samx_motor_is_moving': {'value': 0, 'timestamp': 1686385306.026888}}}, metadata={'stream': 'primary', 'DIID': 353, 'RID': 'd3471acc-309d-43b7-8ff8-f986c3fdecf1', 'point_id': 49, 'scan_id': '8e234698-358e-402d-a272-73e168a72f66', 'queue_id': '7a232746-6c90-44f5-81f5-74ab0ea22d4a'})
 */
export interface DeviceMessage {
  metadata?: Metadata;
  signals: Signals;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface Signals {
  [k: string]: {
    [k: string]: unknown;
  };
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Data = string;
export type Device = string;
export type Timestamp = number;
export type TypeName = string;

/**
 * Message type for sending device monitor updates from the device server.
 *
 * The message is send from the device_server to monitor data coming from larger detector.
 *
 * Args:
 *     device (str): Device name.
 *     data (np.ndarray): Numpy array data from the monitor
 *     metadata (dict, optional): Additional metadata.
 */
export interface DeviceMonitor1DMessage {
  data: Data;
  metadata?: Metadata;
  device: Device;
  timestamp?: Timestamp;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Data = string;
export type Device = string;
export type Timestamp = number;
export type TypeName = string;

/**
 * Message type for sending device monitor updates from the device server.
 *
 * The message is send from the device_server to monitor data coming from larger detector.
 *
 * Args:
 *     device (str): Device name.
 *     data (np.ndarray): Numpy array data from the monitor
 *     metadata (dict, optional): Additional metadata.
 */
export interface DeviceMonitor2DMessage {
  data: Data;
  metadata?: Metadata;
  device: Device;
  timestamp?: Timestamp;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Data = string;
export type Device = string;
export type Signal = string;
export type Timestamp = number;
export type TypeName = string;

/**
 * Message type for sending device preview updates from the device server.
 * The message is sent from the device_server to monitor data streams, usually at
 * a reduced rate compared to the full data stream.
 *
 * Args:
 *     device (str): Device name.
 *     signal (str): Signal name, e.g. "image", "data", "preview".
 *     data (np.ndarray): Numpy array data from the preview.
 *     timestamp (float, optional): Timestamp of the message. Defaults to time.time().
 *     metadata (dict, optional): Additional metadata.
 */
export interface DevicePreviewMessage {
  data: Data;
  metadata?: Metadata;
  device: Device;
  signal: Signal;
  timestamp?: Timestamp;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Device = string;
export type Out =
  | string
  | {
      [k: string]: unknown;
    };
export type Success = boolean;
export type TypeName = string;

/**
 * Message type for sending device RPC return values from the device server
 *
 * Args:
 *     device (str): Device name.
 *     return_val (Any): Return value of the RPC call.
 *     out (str or dict): Output of the RPC call.
 *     success (bool, optional): True if the RPC call was successful. Defaults to True.
 *     metadata (dict, optional): Additional metadata.
 */
export interface DeviceRPCMessage {
  metadata?: Metadata;
  device: Device;
  return_val: ReturnVal;
  out: Out;
  success?: Success;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface ReturnVal {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Device = string;
export type Success = boolean;
export type RequestId = string;
export type TypeName = string;

/**
 * Message type for sending device request status updates from the device server
 *
 * Args:
 *     device (str): Device name.
 *     success (bool): True if the request was successful.
 *     request_id (str): Request ID.
 *     metadata (dict, optional): Additional metadata.
 */
export interface DeviceReqStatusMessage {
  metadata?: Metadata;
  device: Device;
  success: Success;
  request_id: RequestId;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Device = string;
export type Status = number;
export type TypeName = string;

/**
 * Message type for sending device status updates from the device server
 *
 * Args:
 *     device (str): Device name.
 *     status (int): Device status.
 *     metadata (dict, optional): Additional metadata.
 */
export interface DeviceStatusMessage {
  metadata?: Metadata;
  device: Device;
  status: Status;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Device = string;
export type Signal = string;
/**
 * Type of the ROI, e.g. 'rectangle', 'circle', 'polygon'
 */
export type RoiType = string;
export type Timestamp = number;
export type TypeName = string;

/**
 * Message type for sending device user ROI updates to and from the device server.
 *
 * Args:
 *     device (str): Device name.
 *     signal (str): Signal name associated with the ROI.
 *     roi_type (str): Type of the ROI, e.g., 'rectangle', 'circle', 'polygon'.
 *     roi (dict): Dictionary containing the ROI information, e.g., {"x": 100, "y": 200, "width": 50, "height": 50}.
 *     metadata (dict, optional): Additional metadata.
 */
export interface DeviceUserROIMessage {
  metadata?: Metadata;
  device: Device;
  signal: Signal;
  roi_type: RoiType;
  roi: Roi;
  timestamp?: Timestamp;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
/**
 * Dictionary containing the ROI information, e.g. {'x': 100, 'y': 200, 'width': 50, 'height': 50}
 */
export interface Roi {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Endpoint = string;
export type TypeName = string;

/**
 * Message for endpoint information
 *
 * Args:
 *     endpoint (str): Endpoint URL
 *     metadata (dict, optional): Additional metadata.
 */
export interface EndpointInfoMessage {
  metadata?: Metadata;
  endpoint: Endpoint;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Id = string;
export type ErrorMessage = string;
export type CompactErrorMessage = string | null;
export type ExceptionType = string;
export type Device = string | string[] | null;
export type TypeName = string;

export interface ErrorInfo {
  id?: Id;
  error_message: ErrorMessage;
  compact_error_message: CompactErrorMessage;
  exception_type: ExceptionType;
  device?: Device;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type FilePath = string;
export type TypeName = string;

/**
 * File content message to inform about the content of a file
 *
 * Args:
 *     file_path (str): Path to the file.
 *     data (str): Content of the file.
 *     scan_info (dict): Scan information.
 *     metadata (dict, optional): Status metadata. Defaults to None.
 */
export interface FileContentMessage {
  metadata?: Metadata;
  file_path: FilePath;
  data: Data;
  scan_info: ScanInfo;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface Data {
  [k: string]: unknown;
}
export interface ScanInfo {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type FilePath = string;
export type Done = boolean;
export type Successful = boolean;
export type IsMasterFile = boolean;
export type DeviceName = string | string[] | null;
export type FileType = string;
export type HintedH5Entries = {
  [k: string]: string;
} | null;
export type TypeName = string;

/**
 * File message to inform about the status of a file writing operation
 *
 * Args:
 *     file_path (str): Path to the file.
 *     done (bool): True if the file writing operation is done.
 *     successful (bool): True if the file writing operation was successful.
 *     device_name (str): Name of the device. If is_master_file is True, device_name is optional.
 *     is_master_file (bool, optional): True if the file is a master file. Defaults to False.
 *     file_type (str, optional): Type of the file. Defaults to "h5".
 *     hinted_h5_entries (dict[str, str], optional): Dictionary with hinted h5 entries. Defaults to None.
 *                 This allows the file writer to automatically create external links within the master.h5 file
 *                 written by BEC under the entry for the specified device. The dictionary should contain the
 *                 sub-entries and to where these should link in the external h5 file (file_path).
 *                 Example for device_name='eiger', and dict('data' : '/entry/data/data'), the location
 *                 '/entry/collection/devices/eiger/data' within the master file will link to '/entry/data/data'
 *                 of the external file.
 *     metadata (dict, optional): Additional metadata. Defaults to None.
 */
export interface FileMessage {
  metadata?: Metadata;
  file_path: FilePath;
  done: Done;
  successful: Successful;
  is_master_file?: IsMasterFile;
  device_name?: DeviceName;
  file_type?: FileType;
  hinted_h5_entries?: HintedH5Entries;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type SelectedDevice = string;
export type TypeName = string;

/**
 * Message for Auto Update configuration
 *
 * Args:
 *     selected_device (str): the selected device for plotting
 *     metadata (dict, optional): Metadata. Defaults to None.
 */
export interface GUIAutoUpdateConfigMessage {
  metadata?: Metadata;
  selected_device: SelectedDevice;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type TypeName = string;

/**
 * Message for GUI configuration
 *
 * Args:
 *     config (dict): GUI configuration, check widgets for more details
 *     metadata (dict, optional): Metadata. Defaults to None.
 */
export interface GUIConfigMessage {
  metadata?: Metadata;
  config: Config;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface Config {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type TypeName = string;

/**
 * Message for GUI data, i.e. update for DAP processes or scans
 *
 * Args:
 *     data (dict): GUI data
 *     metadata (dict, optional): Metadata. Defaults to None.
 */
export interface GUIDataMessage {
  metadata?: Metadata;
  data: Data;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface Data {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Action = string;
export type TypeName = string;

/**
 * Message for GUI instructions
 *
 * Args:
 *     action (str): Instruction to be executed by the GUI
 *     metadata (dict, optional): Metadata. Defaults to None.
 */
export interface GUIInstructionMessage {
  metadata?: Metadata;
  action: Action;
  parameter: Parameter;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface Parameter {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type TypeName = string;

/**
 * Message for GUI registry state. The dictionary contains the state of the GUI registry.
 *
 * Args:
 *     state (dict[str, dict[Literal["gui_id", "name", "widget_class", "config", "__rpc__", "container_proxy"], str | bool | dict | None]): GUI registry state
 *     metadata (dict, optional): Metadata. Defaults to None.
 */
export interface GUIRegistryStateMessage {
  metadata?: Metadata;
  state: State;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface State {
  [k: string]: {
    [k: string]:
      | string
      | boolean
      | {
          [k: string]: unknown;
        }
      | null;
  };
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type LogType = "trace" | "debug" | "info" | "success" | "warning" | "error" | "critical" | "console_log";
export type LogMsg =
  | {
      [k: string]: unknown;
    }
  | string;
export type TypeName = string;

/**
 * Log message
 *
 * Args:
 *     log_type (Literal["trace", "debug", "info", "success", "warning", "error", "critical", "console_log"]) : Log type.
 *     log_msg (dict or str): Log message.
 *     metadata (dict, optional): Additional metadata.
 */
export interface LogMessage {
  metadata?: Metadata;
  log_type: LogType;
  log_msg: LogMsg;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Host = string;
export type Deployment = string;
export type AvailableAccounts = string[];
export type AtlasLogin = boolean;
export type TypeName = string;

/**
 * Message for public login information
 *
 * Args:
 *     host (str): Hostname
 *     deployment (str): Deployment id
 */
export interface LoginInfoMessage {
  metadata?: Metadata;
  host: Host;
  deployment: Deployment;
  available_accounts: AvailableAccounts;
  atlas_login: AtlasLogin;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type UpdateType = "add" | "remove" | "reload" | "reload_all";
export type MacroName = string | null;
export type FilePath = string | null;
export type TypeName = string;

/**
 * Message for macro updates
 *
 * Args:
 */
export interface MacroUpdateMessage {
  metadata?: Metadata;
  update_type: UpdateType;
  macro_name?: MacroName;
  file_path?: FilePath;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Observer = {
  [k: string]: unknown;
}[];
export type TypeName = string;

/**
 * Message for observer updates
 *
 * Args:
 *     observer (list[dict]): List of observer descriptions (dictionaries).
 *     metadata (dict, optional): Additional metadata.
 */
export interface ObserverMessage {
  metadata?: Metadata;
  observer: Observer;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Queue = string | null;
export type ExecutionId = string | null;
export type AbortAll = boolean | null;
export type TypeName = string;

/**
 * Message type to request aborting a procedure or procedure queue
 *
 * One and only one of the args should be supplied.
 *     Args:
 *         queue (str | None): the procedure queue to abort
 *         execution_id (str | None): the procedure execution to abort
 *         abort_all (bool | None): abort all procedures if true
 */
export interface ProcedureAbortMessage {
  metadata?: Metadata;
  queue?: Queue;
  execution_id?: ExecutionId;
  abort_all?: AbortAll;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Queue = string | null;
export type ExecutionId = string | null;
export type AbortAll = boolean | null;
export type TypeName = string;

/**
 * Message type to request clearing an unhandled procedure or procedure queue
 *
 * One and only one of the args should be supplied.
 *     Args:
 *         queue (str | None): the unhandled procedure queue to clear
 *         execution_id (str | None): the unhandled procedure queue to clear
 *         abort_all (bool | None): clear all procedures if true
 */
export interface ProcedureClearUnhandledMessage {
  metadata?: Metadata;
  queue?: Queue;
  execution_id?: ExecutionId;
  abort_all?: AbortAll;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Identifier = string;
export type Queue = string;
/**
 * @minItems 2
 * @maxItems 2
 */
export type ArgsKwargs = [unknown, unknown];
export type ExecutionId = string;
export type TypeName = string;

/**
 * Message type for sending procedure execution instructions to the scheduler
 *
 * Sent by the  user to the procedure_request topic. It will be consumed by the scan server.
 *     Args:
 *         identifier (str): name of the procedure registered with the server
 *         queue (str): the procedure queue this execution belongs to
 *         args_kwargs (tuple[tuple[Any, ...], dict[str, Any]]): arguments for the procedure function
 */
export interface ProcedureExecutionMessage {
  metadata?: Metadata;
  identifier: Identifier;
  queue: Queue;
  args_kwargs?: ArgsKwargs;
  execution_id: ExecutionId;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type QueueName = string;
export type QueueType = "execution" | "unhandled";
export type TypeName = string;

/**
 * Message type for notifying watchers of changes to queues, mainly meant for GUI to consume
 */
export interface ProcedureQNotifMessage {
  metadata?: Metadata;
  queue_name: QueueName;
  queue_type: QueueType;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Identifier = string;
export type ArgsKwargs = [unknown, unknown] | null;
export type Queue = string | null;
export type ExecutionId = string;
export type TypeName = string;

/**
 * Message type for sending procedure requests to the server
 *
 * Sent by the API server / user to the procedure_request topic. It will be consumed by the procedure manager.
 *     Args:
 *         identifier (str): name of the procedure registered with the server
 *         queue (str | none): a key for the procedure queue
 */
export interface ProcedureRequestMessage {
  metadata?: Metadata;
  identifier: Identifier;
  args_kwargs?: ArgsKwargs;
  queue?: Queue;
  execution_id?: ExecutionId;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type ExecutionId = string;
export type Action = "Started" | "Aborted" | "Finished";
export type Error = string | null;
export type TypeName = string;

/**
 * Message type for notifying watchers of changes to procedure executions, mainly meant for status helper to consume
 */
export interface ProcedureStatusUpdate {
  metadata?: Metadata;
  execution_id: ExecutionId;
  action: Action;
  error?: Error;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface ProcedureWorkerStatus {
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type WorkerQueue = string;
export type ProcedureWorkerStatus = 1 | 2 | 3 | 4 | 5;
export type CurrentExecutionId = string | null;
export type TypeName = string;

/**
 * Message type for sending procedure worker status updates
 *
 * Args:
 *     worker_queue (str): Worker queue ID
 *     status (str): Worker status
 *     current_execution_id (str | None): ID of the current job, only allowed for RUNNING
 */
export interface ProcedureWorkerStatusMessage {
  metadata?: Metadata;
  worker_queue: WorkerQueue;
  status: ProcedureWorkerStatus;
  current_execution_id?: CurrentExecutionId;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Data =
  | {
      [k: string]: unknown;
    }
  | {
      [k: string]: unknown;
    }[];
export type TypeName = string;

/**
 * Message for processed data
 *
 * Args:
 *     data (dict, list[dict]): Dictionary with processed data or list of dictionaries with processed data.
 *     metadata (dict, optional): Metadata. Defaults to None.
 */
export interface ProcessedDataMessage {
  metadata?: Metadata;
  data: Data;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Value = number;
export type MaxValue = number;
export type Done = boolean;
export type TypeName = string;

/**
 * Message for communicating the progress of a long running task
 *
 * Args:
 *     value (float): Current progress value
 *     max_value (float): Maximum progress value
 *     done (bool): True if the task is done
 *     metadata (dict, optional): Metadata. Defaults to None.
 */
export interface ProgressMessage {
  metadata?: Metadata;
  value: Value;
  max_value: MaxValue;
  done: Done;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type QueueId = string;
export type ScanId = (string | null)[];
export type IsScan = boolean[];
export type ScanType = string;
export type Queue = string;
export type TypeName = string;
export type Rid = string;
export type ScanMotors = string[];
export type IsScan1 = boolean;
export type ScanNumber = number | null;
export type ScanId1 = string | null;
export type ReportInstructions =
  | {
      [k: string]: unknown;
    }[]
  | null;
export type RequestBlocks = RequestBlock[];
export type ScanNumber1 = (number | null)[];
export type Status = string;

/**
 * Model for scan queue information entries. It represents a single queue element within a scan queue but
 * may contain multiple request blocks.
 *
 * Args:
 *     queue_id (str): Unique queue ID
 *     scan_id (list[str | None]): List of scan IDs for each request block
 *     is_scan (list[bool]): List indicating whether each request block is a scan
 *     request_blocks (list[RequestBlock]): List of RequestBlock objects representing the requests in the queue entry
 *     scan_number (list[int | None]): List of scan numbers for each request block
 *     status (str): Current status of the queue entry
 *     active_request_block (RequestBlock | None): The currently active request block, if any
 */
export interface QueueInfoEntry {
  queue_id: QueueId;
  scan_id: ScanId;
  is_scan: IsScan;
  request_blocks: RequestBlocks;
  scan_number: ScanNumber1;
  status: Status;
  active_request_block?: RequestBlock | null;
  bec_codec: BecCodecInfo2;
  [k: string]: unknown;
}
/**
 * Model for a request block within a scan queue entry. It represents a single request in the scan queue, e.g. a single scan or rpc call.
 *
 * Args:
 *     msg (ScanQueueMessage): The original scan queue message containing the request details
 *     RID (str): Request ID associated with the request
 *     scan_motors (list[str]): List of motors involved in the scan
 *     readout_priority (dict[Literal["monitored", "baseline", "async", "continuous", "on_request"], list[str]]): Readout priority for the request
 *     is_scan (bool): True if the request is a scan, False if it is an rpc call
 *     scan_number (int | None): Scan number if applicable
 *     scan_id (str | None): Scan ID if applicable
 *     report_instructions (list[dict] | None): List of report instructions for the scan, if any
 */
export interface RequestBlock {
  msg: ScanQueueMessage;
  RID: Rid;
  scan_motors: ScanMotors;
  readout_priority: ReadoutPriority;
  is_scan: IsScan1;
  scan_number: ScanNumber;
  scan_id: ScanId1;
  report_instructions?: ReportInstructions;
  bec_codec: BecCodecInfo1;
  [k: string]: unknown;
}
/**
 * Message type for sending scan requests to the scan queue
 *
 * Sent by the API server / user to the scan_queue topic. It will be consumed by the scan server.
 *     Args:
 *         scan_type (str): one of the registered scan types; either rpc calls or scan types defined in the scan server
 *         parameter (dict): required parameters for the given scan_stype
 *         queue (str): either "primary" or "interception"
 *         metadata (dict, optional): additional metadata to describe the scan
 *     Examples:
 *         >>> ScanQueueMessage(scan_type="dscan", parameter={"motor1": "samx", "from_m1:": -5, "to_m1": 5, "steps_m1": 10, "motor2": "samy", "from_m2": -5, "to_m2": 5, "steps_m2": 10, "exp_time": 0.1})
 */
export interface ScanQueueMessage {
  metadata?: Metadata;
  scan_type: ScanType;
  parameter: Parameter;
  queue?: Queue;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface Parameter {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
export interface ReadoutPriority {
  [k: string]: string[];
}
export interface BecCodecInfo1 {
  type_name: TypeName;
  [k: string]: unknown;
}
export interface BecCodecInfo2 {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type TypeName = string;

/**
 * Message for raw data that was not encoded as a BECMessage.
 * The data dictionary is simply the raw data loaded using json.loads
 *
 * Args:
 *     data (Any): Raw data
 *     metadata (dict, optional): Metadata. Defaults to None.
 */
export interface RawMessage {
  metadata?: Metadata;
  data: Data;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface Data {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type ScanType = string;
export type Queue = string;
export type TypeName = string;
export type Rid = string;
export type ScanMotors = string[];
export type IsScan = boolean;
export type ScanNumber = number | null;
export type ScanId = string | null;
export type ReportInstructions =
  | {
      [k: string]: unknown;
    }[]
  | null;

/**
 * Model for a request block within a scan queue entry. It represents a single request in the scan queue, e.g. a single scan or rpc call.
 *
 * Args:
 *     msg (ScanQueueMessage): The original scan queue message containing the request details
 *     RID (str): Request ID associated with the request
 *     scan_motors (list[str]): List of motors involved in the scan
 *     readout_priority (dict[Literal["monitored", "baseline", "async", "continuous", "on_request"], list[str]]): Readout priority for the request
 *     is_scan (bool): True if the request is a scan, False if it is an rpc call
 *     scan_number (int | None): Scan number if applicable
 *     scan_id (str | None): Scan ID if applicable
 *     report_instructions (list[dict] | None): List of report instructions for the scan, if any
 */
export interface RequestBlock {
  msg: ScanQueueMessage;
  RID: Rid;
  scan_motors: ScanMotors;
  readout_priority: ReadoutPriority;
  is_scan: IsScan;
  scan_number: ScanNumber;
  scan_id: ScanId;
  report_instructions?: ReportInstructions;
  bec_codec: BecCodecInfo1;
  [k: string]: unknown;
}
/**
 * Message type for sending scan requests to the scan queue
 *
 * Sent by the API server / user to the scan_queue topic. It will be consumed by the scan server.
 *     Args:
 *         scan_type (str): one of the registered scan types; either rpc calls or scan types defined in the scan server
 *         parameter (dict): required parameters for the given scan_stype
 *         queue (str): either "primary" or "interception"
 *         metadata (dict, optional): additional metadata to describe the scan
 *     Examples:
 *         >>> ScanQueueMessage(scan_type="dscan", parameter={"motor1": "samx", "from_m1:": -5, "to_m1": 5, "steps_m1": 10, "motor2": "samy", "from_m2": -5, "to_m2": 5, "steps_m2": 10, "exp_time": 0.1})
 */
export interface ScanQueueMessage {
  metadata?: Metadata;
  scan_type: ScanType;
  parameter: Parameter;
  queue?: Queue;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface Parameter {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
export interface ReadoutPriority {
  [k: string]: string[];
}
export interface BecCodecInfo1 {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Accepted = boolean;
export type Message =
  | string
  | {
      [k: string]: unknown;
    }
  | null;
export type TypeName = string;

/**
 * Message type for sending back decisions on the acceptance of requests
 *
 * Args:
 *     accepted (bool): True if the request was accepted
 *     message (str, dict, optional): String or dictionary describing the decision, e.g. "Invalid request"
 *     metadata (dict, optional): Additional metadata, defaults to None.
 *
 * Examples:
 *     >>> RequestResponseMessage(accepted=True, message="Request accepted")
 */
export interface RequestResponseMessage {
  metadata?: Metadata;
  accepted: Accepted;
  message?: Message;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type ScanId = string;
export type TypeName = string;

/**
 * Message type for sending scan baseline data from the scan bundler
 *
 * Args:
 *     scan_id (str): Scan ID.
 *     data (dict): Scan baseline data.
 *     metadata (dict, optional): Additional metadata.
 */
export interface ScanBaselineMessage {
  metadata?: Metadata;
  scan_id: ScanId;
  data: Data;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface Data {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type ScanId = string;
export type ScanNumber = number;
export type DatasetNumber = number;
export type FilePath = string;
export type ExitStatus = "closed" | "aborted" | "halted";
export type StartTime = number;
export type EndTime = number;
export type ScanName = string;
export type NumPoints = number;
export type RequestInputs = {
  [k: string]: unknown;
} | null;
export type StoredDataInfo = {
  [k: string]: {
    [k: string]: _StoredDataInfo;
  };
} | null;
export type Shape = number[];
export type Dtype = string | null;
export type TypeName = string;

/**
 * Message type for sending scan history data from the file writer
 *
 * Args:
 *     scan_id (str): Scan ID.
 *     scan_number (int): Scan number.
 *     dataset_number (int): Dataset number.
 *     file_path (str): Path to the file.
 *     exit_status (Literal["closed", "aborted", "halted"]): Exit status of the scan.
 *     start_time (float): Start time of the scan.
 *     end_time (float): End time of the scan.
 *     scan_name (str): Name of the scan.
 *     num_points (int): Number of points in the scan.
 *     request_inputs (dict, optional): Inputs for the scan request, if available.
 *     stored_data_info (dict[str, dict[str, _StoredDataInfo]], optional): Information about the stored data for each device in the scan.
 *     metadata (dict, optional): Additional metadata.
 */
export interface ScanHistoryMessage {
  metadata?: Metadata;
  scan_id: ScanId;
  scan_number: ScanNumber;
  dataset_number: DatasetNumber;
  file_path: FilePath;
  exit_status: ExitStatus;
  start_time: StartTime;
  end_time: EndTime;
  scan_name: ScanName;
  num_points: NumPoints;
  request_inputs?: RequestInputs;
  stored_data_info?: StoredDataInfo;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
/**
 * Internal class to store data info for each device in the scan history message
 *
 * Args:
 *     shape (tuple): Shape of the data for the device.
 *     dtype (str, optional): Data type of the data for the device. Defaults to None.
 */
export interface _StoredDataInfo {
  shape?: Shape;
  dtype?: Dtype;
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type PointId = number;
export type ScanId = string;
export type TypeName = string;

/**
 * Message type for sending scan segment data from the scan bundler
 *
 * Args:
 *     point_id (int): Point ID from the scan segment.
 *     scan_id (str): Scan ID.
 *     data (dict): Scan segment data.
 *     metadata (dict, optional): Additional metadata.
 */
export interface ScanMessage {
  metadata?: Metadata;
  point_id: PointId;
  scan_id: ScanId;
  data: Data;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface Data {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Status = string;
export type QueueId = string;
export type QueueId1 = string;
export type ScanId = (string | null)[];
export type IsScan = boolean[];
export type ScanType = string;
export type Queue = string;
export type TypeName = string;
export type Rid = string;
export type ScanMotors = string[];
export type IsScan1 = boolean;
export type ScanNumber = number | null;
export type ScanId1 = string | null;
export type ReportInstructions =
  | {
      [k: string]: unknown;
    }[]
  | null;
export type RequestBlocks = RequestBlock[];
export type ScanNumber1 = (number | null)[];
export type Status1 = string;
export type Queue1 = string;

/**
 * Sent after removal from the active queue. Contains information about the scan.
 *
 * Called by the ScanWorker after processing the QueueInstructionItem. It can be checked by any service.
 *
 * Args:
 *     status (str): Current scan status
 *     queue_id (str): Unique queue ID
 *     info (QueueInfoEntry): Information about the scan in the queue
 *     queue (str): Defaults to "primary" queue. Information about the queue the scan was in.
 *     metadata (dict, optional): Additional metadata to describe the scan
 *
 * Examples:
 *     >>> ScanQueueHistoryMessage(status="open", queue_id="1234", info={"positions": {"samx": 0.5, "samy": 0.5}})
 */
export interface ScanQueueHistoryMessage {
  metadata?: Metadata;
  status: Status;
  queue_id: QueueId;
  info: QueueInfoEntry;
  queue?: Queue1;
  bec_codec: BecCodecInfo3;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
/**
 * Model for scan queue information entries. It represents a single queue element within a scan queue but
 * may contain multiple request blocks.
 *
 * Args:
 *     queue_id (str): Unique queue ID
 *     scan_id (list[str | None]): List of scan IDs for each request block
 *     is_scan (list[bool]): List indicating whether each request block is a scan
 *     request_blocks (list[RequestBlock]): List of RequestBlock objects representing the requests in the queue entry
 *     scan_number (list[int | None]): List of scan numbers for each request block
 *     status (str): Current status of the queue entry
 *     active_request_block (RequestBlock | None): The currently active request block, if any
 */
export interface QueueInfoEntry {
  queue_id: QueueId1;
  scan_id: ScanId;
  is_scan: IsScan;
  request_blocks: RequestBlocks;
  scan_number: ScanNumber1;
  status: Status1;
  active_request_block?: RequestBlock | null;
  bec_codec: BecCodecInfo2;
  [k: string]: unknown;
}
/**
 * Model for a request block within a scan queue entry. It represents a single request in the scan queue, e.g. a single scan or rpc call.
 *
 * Args:
 *     msg (ScanQueueMessage): The original scan queue message containing the request details
 *     RID (str): Request ID associated with the request
 *     scan_motors (list[str]): List of motors involved in the scan
 *     readout_priority (dict[Literal["monitored", "baseline", "async", "continuous", "on_request"], list[str]]): Readout priority for the request
 *     is_scan (bool): True if the request is a scan, False if it is an rpc call
 *     scan_number (int | None): Scan number if applicable
 *     scan_id (str | None): Scan ID if applicable
 *     report_instructions (list[dict] | None): List of report instructions for the scan, if any
 */
export interface RequestBlock {
  msg: ScanQueueMessage;
  RID: Rid;
  scan_motors: ScanMotors;
  readout_priority: ReadoutPriority;
  is_scan: IsScan1;
  scan_number: ScanNumber;
  scan_id: ScanId1;
  report_instructions?: ReportInstructions;
  bec_codec: BecCodecInfo1;
  [k: string]: unknown;
}
/**
 * Message type for sending scan requests to the scan queue
 *
 * Sent by the API server / user to the scan_queue topic. It will be consumed by the scan server.
 *     Args:
 *         scan_type (str): one of the registered scan types; either rpc calls or scan types defined in the scan server
 *         parameter (dict): required parameters for the given scan_stype
 *         queue (str): either "primary" or "interception"
 *         metadata (dict, optional): additional metadata to describe the scan
 *     Examples:
 *         >>> ScanQueueMessage(scan_type="dscan", parameter={"motor1": "samx", "from_m1:": -5, "to_m1": 5, "steps_m1": 10, "motor2": "samy", "from_m2": -5, "to_m2": 5, "steps_m2": 10, "exp_time": 0.1})
 */
export interface ScanQueueMessage {
  metadata?: Metadata1;
  scan_type: ScanType;
  parameter: Parameter;
  queue?: Queue;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata1 {
  [k: string]: unknown;
}
export interface Parameter {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
export interface ReadoutPriority {
  [k: string]: string[];
}
export interface BecCodecInfo1 {
  type_name: TypeName;
  [k: string]: unknown;
}
export interface BecCodecInfo2 {
  type_name: TypeName;
  [k: string]: unknown;
}
export interface BecCodecInfo3 {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type ScanType = string;
export type Queue = string;
export type TypeName = string;

/**
 * Message type for sending scan requests to the scan queue
 *
 * Sent by the API server / user to the scan_queue topic. It will be consumed by the scan server.
 *     Args:
 *         scan_type (str): one of the registered scan types; either rpc calls or scan types defined in the scan server
 *         parameter (dict): required parameters for the given scan_stype
 *         queue (str): either "primary" or "interception"
 *         metadata (dict, optional): additional metadata to describe the scan
 *     Examples:
 *         >>> ScanQueueMessage(scan_type="dscan", parameter={"motor1": "samx", "from_m1:": -5, "to_m1": 5, "steps_m1": 10, "motor2": "samy", "from_m2": -5, "to_m2": 5, "steps_m2": 10, "exp_time": 0.1})
 */
export interface ScanQueueMessage {
  metadata?: Metadata;
  scan_type: ScanType;
  parameter: Parameter;
  queue?: Queue;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface Parameter {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type ScanId = string | string[] | null[] | null;
export type Action = "pause" | "deferred_pause" | "continue" | "abort" | "clear" | "restart" | "halt" | "resume";
export type Queue = string;
export type TypeName = string;

/**
 * Message type for sending scan queue modifications
 *
 * Args:
 *     scan_id (str): Unique scan ID
 *     action (str): One of the actions defined in ACTIONS: ("pause", "deferred_pause", "continue", "abort", "clear", "restart", "halt", "resume")
 *     parameter (dict): Additional parameters for the action
 *     queue (str): Defaults to "primary" queue. The name of the queue that receives the modification.
 *     metadata (dict, optional): Additional metadata to describe and identify the scan.
 *
 * Examples:
 *     >>> ScanQueueModificationMessage(scan_id=scan_id, action="abort", parameter={})
 */
export interface ScanQueueModificationMessage {
  metadata?: Metadata;
  scan_id: ScanId;
  action: Action;
  parameter: Parameter;
  queue?: Queue;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface Parameter {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type ScanId = string;
export type Action = "move_up" | "move_down" | "move_top" | "move_bottom" | "move_to";
export type Queue = string;
export type TargetPosition = number | null;
export type TypeName = string;

/**
 * Message type for sending scan queue order modifications
 *
 * Args:
 *     scan_id (str): Unique scan ID
 *     action (str): One of the actions defined in ACTIONS: ("move_up", "move_down", "move_top", "move_bottom", "move_to")
 *     queue (str): Defaults to "primary" queue. The name of the queue that receives the modification.
 *     metadata (dict, optional): Additional metadata to describe and identify the scan.
 *
 * Examples:
 *     >>> ScanQueueOrderMessage(scan_id=scan_id, action="move_up")
 */
export interface ScanQueueOrderMessage {
  metadata?: Metadata;
  scan_id: ScanId;
  action: Action;
  queue?: Queue;
  target_position?: TargetPosition;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type QueueId = string;
export type ScanId = (string | null)[];
export type IsScan = boolean[];
export type ScanType = string;
export type Queue = string;
export type TypeName = string;
export type Rid = string;
export type ScanMotors = string[];
export type IsScan1 = boolean;
export type ScanNumber = number | null;
export type ScanId1 = string | null;
export type ReportInstructions =
  | {
      [k: string]: unknown;
    }[]
  | null;
export type RequestBlocks = RequestBlock[];
export type ScanNumber1 = (number | null)[];
export type Status = string;
export type Info = QueueInfoEntry[];
export type Status1 = string;

/**
 * Model for scan queue status information. It represents the status of a single queue, e.g. "primary" or "interception".
 *
 * Args:
 *     info (list[QueueInfoEntry]): List of QueueInfoEntry objects representing the current queue status
 *     status (str): Current status of the scan queue
 */
export interface ScanQueueStatus {
  info: Info;
  status: Status1;
  bec_codec: BecCodecInfo3;
  [k: string]: unknown;
}
/**
 * Model for scan queue information entries. It represents a single queue element within a scan queue but
 * may contain multiple request blocks.
 *
 * Args:
 *     queue_id (str): Unique queue ID
 *     scan_id (list[str | None]): List of scan IDs for each request block
 *     is_scan (list[bool]): List indicating whether each request block is a scan
 *     request_blocks (list[RequestBlock]): List of RequestBlock objects representing the requests in the queue entry
 *     scan_number (list[int | None]): List of scan numbers for each request block
 *     status (str): Current status of the queue entry
 *     active_request_block (RequestBlock | None): The currently active request block, if any
 */
export interface QueueInfoEntry {
  queue_id: QueueId;
  scan_id: ScanId;
  is_scan: IsScan;
  request_blocks: RequestBlocks;
  scan_number: ScanNumber1;
  status: Status;
  active_request_block?: RequestBlock | null;
  bec_codec: BecCodecInfo2;
  [k: string]: unknown;
}
/**
 * Model for a request block within a scan queue entry. It represents a single request in the scan queue, e.g. a single scan or rpc call.
 *
 * Args:
 *     msg (ScanQueueMessage): The original scan queue message containing the request details
 *     RID (str): Request ID associated with the request
 *     scan_motors (list[str]): List of motors involved in the scan
 *     readout_priority (dict[Literal["monitored", "baseline", "async", "continuous", "on_request"], list[str]]): Readout priority for the request
 *     is_scan (bool): True if the request is a scan, False if it is an rpc call
 *     scan_number (int | None): Scan number if applicable
 *     scan_id (str | None): Scan ID if applicable
 *     report_instructions (list[dict] | None): List of report instructions for the scan, if any
 */
export interface RequestBlock {
  msg: ScanQueueMessage;
  RID: Rid;
  scan_motors: ScanMotors;
  readout_priority: ReadoutPriority;
  is_scan: IsScan1;
  scan_number: ScanNumber;
  scan_id: ScanId1;
  report_instructions?: ReportInstructions;
  bec_codec: BecCodecInfo1;
  [k: string]: unknown;
}
/**
 * Message type for sending scan requests to the scan queue
 *
 * Sent by the API server / user to the scan_queue topic. It will be consumed by the scan server.
 *     Args:
 *         scan_type (str): one of the registered scan types; either rpc calls or scan types defined in the scan server
 *         parameter (dict): required parameters for the given scan_stype
 *         queue (str): either "primary" or "interception"
 *         metadata (dict, optional): additional metadata to describe the scan
 *     Examples:
 *         >>> ScanQueueMessage(scan_type="dscan", parameter={"motor1": "samx", "from_m1:": -5, "to_m1": 5, "steps_m1": 10, "motor2": "samy", "from_m2": -5, "to_m2": 5, "steps_m2": 10, "exp_time": 0.1})
 */
export interface ScanQueueMessage {
  metadata?: Metadata;
  scan_type: ScanType;
  parameter: Parameter;
  queue?: Queue;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface Parameter {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
export interface ReadoutPriority {
  [k: string]: string[];
}
export interface BecCodecInfo1 {
  type_name: TypeName;
  [k: string]: unknown;
}
export interface BecCodecInfo2 {
  type_name: TypeName;
  [k: string]: unknown;
}
export interface BecCodecInfo3 {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type QueueId = string;
export type ScanId = (string | null)[];
export type IsScan = boolean[];
export type ScanType = string;
export type Queue1 = string;
export type TypeName = string;
export type Rid = string;
export type ScanMotors = string[];
export type IsScan1 = boolean;
export type ScanNumber = number | null;
export type ScanId1 = string | null;
export type ReportInstructions =
  | {
      [k: string]: unknown;
    }[]
  | null;
export type RequestBlocks = RequestBlock[];
export type ScanNumber1 = (number | null)[];
export type Status = string;
export type Info = QueueInfoEntry[];
export type Status1 = string;

/**
 * Message type for sending scan queue status updates
 *
 * Args:
 *     queue (dict): Dictionary containing the current queue status. Must contain a "primary" key.
 *     metadata (dict, optional): Additional metadata to describe and identify the ScanQueueStatus.
 *
 * Examples:
 *     >>> ScanQueueStatusMessage(queue={"primary": {}}, metadata={"RID": "1234"})
 */
export interface ScanQueueStatusMessage {
  metadata?: Metadata;
  queue: Queue;
  bec_codec: BecCodecInfo4;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface Queue {
  [k: string]: ScanQueueStatus;
}
/**
 * Model for scan queue status information. It represents the status of a single queue, e.g. "primary" or "interception".
 *
 * Args:
 *     info (list[QueueInfoEntry]): List of QueueInfoEntry objects representing the current queue status
 *     status (str): Current status of the scan queue
 */
export interface ScanQueueStatus {
  info: Info;
  status: Status1;
  bec_codec: BecCodecInfo3;
  [k: string]: unknown;
}
/**
 * Model for scan queue information entries. It represents a single queue element within a scan queue but
 * may contain multiple request blocks.
 *
 * Args:
 *     queue_id (str): Unique queue ID
 *     scan_id (list[str | None]): List of scan IDs for each request block
 *     is_scan (list[bool]): List indicating whether each request block is a scan
 *     request_blocks (list[RequestBlock]): List of RequestBlock objects representing the requests in the queue entry
 *     scan_number (list[int | None]): List of scan numbers for each request block
 *     status (str): Current status of the queue entry
 *     active_request_block (RequestBlock | None): The currently active request block, if any
 */
export interface QueueInfoEntry {
  queue_id: QueueId;
  scan_id: ScanId;
  is_scan: IsScan;
  request_blocks: RequestBlocks;
  scan_number: ScanNumber1;
  status: Status;
  active_request_block?: RequestBlock | null;
  bec_codec: BecCodecInfo2;
  [k: string]: unknown;
}
/**
 * Model for a request block within a scan queue entry. It represents a single request in the scan queue, e.g. a single scan or rpc call.
 *
 * Args:
 *     msg (ScanQueueMessage): The original scan queue message containing the request details
 *     RID (str): Request ID associated with the request
 *     scan_motors (list[str]): List of motors involved in the scan
 *     readout_priority (dict[Literal["monitored", "baseline", "async", "continuous", "on_request"], list[str]]): Readout priority for the request
 *     is_scan (bool): True if the request is a scan, False if it is an rpc call
 *     scan_number (int | None): Scan number if applicable
 *     scan_id (str | None): Scan ID if applicable
 *     report_instructions (list[dict] | None): List of report instructions for the scan, if any
 */
export interface RequestBlock {
  msg: ScanQueueMessage;
  RID: Rid;
  scan_motors: ScanMotors;
  readout_priority: ReadoutPriority;
  is_scan: IsScan1;
  scan_number: ScanNumber;
  scan_id: ScanId1;
  report_instructions?: ReportInstructions;
  bec_codec: BecCodecInfo1;
  [k: string]: unknown;
}
/**
 * Message type for sending scan requests to the scan queue
 *
 * Sent by the API server / user to the scan_queue topic. It will be consumed by the scan server.
 *     Args:
 *         scan_type (str): one of the registered scan types; either rpc calls or scan types defined in the scan server
 *         parameter (dict): required parameters for the given scan_stype
 *         queue (str): either "primary" or "interception"
 *         metadata (dict, optional): additional metadata to describe the scan
 *     Examples:
 *         >>> ScanQueueMessage(scan_type="dscan", parameter={"motor1": "samx", "from_m1:": -5, "to_m1": 5, "steps_m1": 10, "motor2": "samy", "from_m2": -5, "to_m2": 5, "steps_m2": 10, "exp_time": 0.1})
 */
export interface ScanQueueMessage {
  metadata?: Metadata1;
  scan_type: ScanType;
  parameter: Parameter;
  queue?: Queue1;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata1 {
  [k: string]: unknown;
}
export interface Parameter {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
export interface ReadoutPriority {
  [k: string]: string[];
}
export interface BecCodecInfo1 {
  type_name: TypeName;
  [k: string]: unknown;
}
export interface BecCodecInfo2 {
  type_name: TypeName;
  [k: string]: unknown;
}
export interface BecCodecInfo3 {
  type_name: TypeName;
  [k: string]: unknown;
}
export interface BecCodecInfo4 {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type ScanId = string | null;
export type Status = "open" | "paused" | "aborted" | "halted" | "closed";
export type ScanNumber = number | null;
export type SessionId = string | null;
/**
 * Number of points in the scan. Only relevant if the number of points is determined by BEC.
 */
export type NumPoints = number | null;
/**
 * Name of the scan, e.g. 'line_scan'
 */
export type ScanName = string | null;
/**
 * Type of scan
 */
export type ScanType = ("step" | "fly") | null;
export type DatasetNumber = number | null;
export type ScanReportDevices = string[] | null;
export type UserMetadata = {
  [k: string]: unknown;
} | null;
export type ReadoutPriority = {
  [k: string]: string[];
} | null;
export type ScanParameters = {
  [k: string]: unknown;
} | null;
export type RequestInputs = {
  [k: string]: unknown;
} | null;
export type Timestamp = number;
export type TypeName = string;

/**
 * Message type for sending scan status updates.
 *
 * Args:
 *     scan_id (str): Unique scan ID
 *     status (Literal["open", "paused", "aborted", "halted", "closed"]) : Current scan status
 *     scan_number (int, optional): Scan number
 *     session_id (str, optional): Session ID
 *     num_points (int, optional): Number of points in the scan. Only relevant if the number of points is determined by BEC.
 *     scan_name (str, optional): Name of the scan, e.g. 'line_scan'
 *     scan_type (Literal["step", "fly"], optional): Type of scan
 *     dataset_number (int, optional): Dataset number
 *     scan_report_devices (list[str], optional): List of devices that are part of the scan report
 *     user_metadata (dict, optional): User metadata
 *     readout_priority (dict[Literal["monitored", "baseline", "async", "continuous", "on_request"], list[str]], optional): Readout priority
 *     scan_parameters (dict[Literal["exp_time", "frames_per_trigger", "settling_time", "readout_time"] | str, Any], optional): Scan parameters such as exposure time, frames per trigger, settling time, readout time
 *     request_inputs (dict[Literal["arg_bundle", "inputs", "kwargs"], Any], optional): Scan input
 *     info (dict): Dictionary containing additional information about the scan
 *     timestamp (float, optional): Timestamp of the message. Defaults to time.time()
 *
 * Examples:
 *     >>> ScanStatusMessage(scan_id="1234", status="open", info={"positions": {"samx": 0.5, "samy": 0.5}})
 */
export interface ScanStatusMessage {
  metadata?: Metadata;
  scan_id: ScanId;
  status: Status;
  scan_number?: ScanNumber;
  session_id?: SessionId;
  num_points?: NumPoints;
  scan_name?: ScanName;
  scan_type?: ScanType;
  dataset_number?: DatasetNumber;
  scan_report_devices?: ScanReportDevices;
  user_metadata?: UserMetadata;
  readout_priority?: ReadoutPriority;
  scan_parameters?: ScanParameters;
  request_inputs?: RequestInputs;
  info: Info;
  timestamp?: Timestamp;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface Info {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type ScriptId = string;
export type Status = "running" | "completed" | "failed" | "aborted";
export type CurrentLines = number[] | null;
export type Traceback = string | null;
export type TypeName = string;

/**
 * Message for script execution
 *
 * Args:
 *     script_id (str): Unique identifier for the script
 *     status (Literal["running", "completed", "failed", "aborted"]): Execution status
 *     current_lines (list[int], optional): Current line numbers being executed. Defaults to None.
 *     traceback (str, optional): Traceback information. Defaults to None.
 */
export interface ScriptExecutionInfoMessage {
  metadata?: Metadata;
  script_id: ScriptId;
  status: Status;
  current_lines?: CurrentLines;
  traceback?: Traceback;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Name = string;
export type TypeName = string;

/**
 * Message for service metrics
 *
 * Args:
 *     name (str): Name of the service.
 *     metrics (dict): Dictionary with service metrics.
 *     metadata (dict, optional): Additional metadata.
 */
export interface ServiceMetricMessage {
  metadata?: Metadata;
  name: Name;
  metrics: Metrics;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface Metrics {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Action = "restart";
export type TypeName = string;

/**
 * Message for service requests
 *
 * Args:
 *     action (Literal["restart"]): Action to be executed by the service
 *     metadata (dict, optional): Metadata. Defaults to None.
 */
export interface ServiceRequestMessage {
  metadata?: Metadata;
  action: Action;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type TypeName = string;

/**
 * Message for service responses
 *
 * Args:
 *     response (dict): Service response
 *     metadata (dict, optional): Metadata. Defaults to None.
 */
export interface ServiceResponseMessage {
  metadata?: Metadata;
  response: Response;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface Response {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Name = string;
/**
 * BEC status enum
 */
export type BECStatus = 2 | 1 | 0 | -1;
export type TypeName = string;

/**
 * Status message
 *
 * Args:
 *     name (str): Name of the status.
 *     status (BECStatus): Value of the BECStatus enum (RUNNING = 2,  BUSY = 1, IDLE = 0, ERROR = -1).
 *     info (dict): Status info.
 *     metadata (dict, optional): Additional metadata.
 */
export interface StatusMessage {
  metadata?: Metadata;
  name: Name;
  status: BECStatus;
  info: Info;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface Info {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type TypeName = string;

/**
 * Message to inform about a global variable
 *
 * Args:
 *     value (Any): Variable value, can be of any type.
 *     metadata (dict, optional): Additional metadata.
 */
export interface VariableMessage {
  metadata?: Metadata;
  value: Value;
  bec_codec: BecCodecInfo;
  [k: string]: unknown;
}
export interface Metadata {
  [k: string]: unknown;
}
export interface Value {
  [k: string]: unknown;
}
export interface BecCodecInfo {
  type_name: TypeName;
  [k: string]: unknown;
}
/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Shape = number[];
export type Dtype = string | null;

/**
 * Internal class to store data info for each device in the scan history message
 *
 * Args:
 *     shape (tuple): Shape of the data for the device.
 *     dtype (str, optional): Data type of the data for the device. Defaults to None.
 */
export interface _StoredDataInfo {
  shape?: Shape;
  dtype?: Dtype;
  [k: string]: unknown;
}
